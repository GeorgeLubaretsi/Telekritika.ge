<?php
/**
 * Save segment entity
 *
 * @package Segment
 */

 
// start a new sticky form session in case of failure
elgg_make_sticky_form('segment');

// save or preview
$save = (bool)get_input('save');

// store errors to pass along
$error = FALSE;
$error_forward_url = REFERER;
$user = elgg_get_logged_in_user_entity();

// edit or create a new entity
$guid = get_input('guid');
if ($guid) {
	$entity = get_entity($guid);
	if (elgg_instanceof($entity, 'object', 'segment') && $entity->canEdit()) {
		$segment = $entity;
	} else {
		register_error(elgg_echo('segment:error:post_not_found'));
		forward(get_input('forward', REFERER));
	}

	// save some data for revisions once we save the new edit
	$revision_text = $segment->description;
	$new_post = $segment->new_post;
    $old = true;
} else {
	$segment = new ElggSegment();
	$segment->subtype = 'segment';
	$new_post = TRUE;
}

// set the previous status for the hooks to update the time_created and river entries
$old_status = $segment->status;

/*
 TV Channel $container_guid
Date $segment_date
Start time $segment_start_hour  $segment_start_minute
End time $segment_end_hour  $segment_end_minute
Link to video $videolink
Title $title
Summary $excerpt
Sequence in news broadcast (1st, 2nd, 3rd segment, etc.) $sequence
Duration (=end time-start time) <-autogenerated
*/



// set defaults and required values.
$values = array(
	'title' => elgg_get_excerpt($values['description'], 35),
	'description' => '',
	'status' => 'draft',
	'access_id' => ACCESS_DEFAULT,
	'comments_on' => 'On',
	//'excerpt' => '',
    'tags' => '',
	'events' => '',
	'container_guid' => (int)get_input('container_guid'),
    'broadcast_type' => '',
    'segment_date' => '',
    'segment_start_hour' => (int)get_input('segment_start_hour'),
    'segment_start_minute' => (int)get_input('segment_start_minute'),
    'segment_start_second' => (int)get_input('segment_start_second'),
    'segment_end_hour' => (int)get_input('segment_end_hour'),
    'segment_end_minute' => (int)get_input('segment_end_minute'),
    'segment_end_second' => (int)get_input('segment_end_second'),
    'duration_minute' => (int)get_input('duration_minute'),
    'duration_second' => (int)get_input('duration_second'),
    'videolink' => '',
    'sequence' => '',
    'admincommented' => time()
);

$duration = return_duration_in_seconds($values['segment_start_hour'], $values['segment_start_minute'], $values['segment_start_second'], $values['segment_end_hour'], $values['segment_end_minute'], $values['segment_end_second']);

$values['duration'] = $duration == 0 || empty($duration) ? ((int)get_input("duration_minute", 0)*60) + (int)get_input("duration_second", 0) : $duration;

// fail if a required entity isn't set
$required = array('description');

// load from POST and do sanity and access checking
foreach ($values as $name => $default) {
	$value = get_input($name, $default);

	if (in_array($name, $required) && empty($value)) {
		$error = elgg_echo("segment:error:missing:$name");
	}

	if ($error) {
		break;
	}

	switch ($name) {
        case 'tags':
        case 'events':
            if ($value) {
                $values[$name] = string_to_tag_array_mod($value);
            } else {
                $values[$name] = array("");
//                unset ($values[$name]);
            }
            break;

/*		case 'excerpt':
			if ($value) {
				$value = elgg_get_excerpt($value);
			} else {
				$value = elgg_get_excerpt($values['description']);
			}
			$values[$name] = $value;
			break;
*/
		case 'container_guid':
			// this can't be empty or saving the base entity fails
			if (!empty($value)) {
			    $values[$name] = $value;
			} else {
				unset($values[$name]);
			}
			break;

		// don't try to set the guid
		case 'guid':
			unset($values['guid']);
			break;

		default:
			$values[$name] = $value;
			break;
	}
}


// assign values to the entity, stopping on error.
if (!$error) {
    elgg_set_ignore_access(true);
	foreach ($values as $name => $value) {
		if (FALSE === ($segment->$name = $value)) {
			$error = elgg_echo('segment:error:cannot_save' . "$name=$value");
			break;
		}
	}
}

if($old == true && $segment->status == "published"){
    $relatedCommentaries = $segment->getEntitiesFromRelationship("linked_segment", 1);
    if($relatedCommentaries){   
        foreach($relatedCommentaries as $commentary){
            $tags = array();
            $events = array();
            $categories = array();
            $linked_segments = $commentary->getEntitiesFromRelationship("linked_segment", 0);
            foreach($linked_segments as $linked_segment){
                if($newtags = $linked_segment->tags)
                    if(is_array($newtags)){ $tags = array_merge($tags, $newtags); }else{ $tags[] = $newtags; }       
                if($newevents = $linked_segment->events)
                    if(is_array($newevents)){ $events = array_merge($events, $newevents); }else{ $events[] = $newevents; }       
                if($newuniversal_categories = $linked_segment->universal_categories)
                    if(is_array($newuniversal_categories)){ $universal_categories = array_merge($universal_categories, $newuniversal_categories); }else{ $universal_categories[] = $newuniversal_categories; }       
            }
            if(!empty($tags))$commentary->tags = array_unique(array_filter($tags));
            if(!empty($events))$commentary->events = array_unique(array_filter($events));
            if(!empty($universal_categories))$commentary->universal_categories = array_unique(array_filter($universal_categories));
        }        
    }    
}
// only try to save base entity if no errors
if (!$error) {
	if ($segment->save()) {
		// remove sticky form entries
		elgg_clear_sticky_form('segment');

		// remove autosave draft if exists
		$segment->clearAnnotations('segment_auto_save');

		// no longer a brand new post.
		$segment->clearMetadata('new_post');

		// if this was an edit, create a revision annotation
		if (!$new_post && $revision_text) {
			$segment->annotate('segment_revision', $revision_text);
		}

		system_message(elgg_echo('segment:message:saved'));

		$status = $segment->status;
		$db_prefix = elgg_get_config('dbprefix');

		// add to river if changing status or published, regardless of new post
		// because we remove it for drafts.
		if (($new_post || $old_status == 'draft') && $status == 'published') {
            //grouping by broafcast so if one is already published with same broadcast, dont add to river
            /*if(!river_contains_broadcast(get_input('broadcast_type'), get_input('segment_date'), get_input('container_guid'))){
                add_to_river('river/object/segment/create', 'create', $segment->owner_guid, $segment->getGUID());
            } */
                        
			if ($guid) {
				$segment->time_created = time();
				$segment->save();
			}
		} elseif ($old_status == 'published' && $status == 'draft') {
			elgg_delete_river(array(
				'object_guid' => $segment->guid,
				'action_type' => 'create',
			));
		}
//elgg_push_context()
//        if ($segment->status == 'published' || $save == false) {
//        elgg_in_context('edit')

		if (elgg_is_admin_logged_in() || get_input('context') == "edit") {
			forward($segment->getURL());
		} else {
            $_SESSION['segment_next_container_guid'] = get_input('container_guid');
            $_SESSION['segment_next_sequence'] = get_input('sequence')+1;
            $_SESSION['segment_next_broadcast_type'] = get_input('broadcast_type');
            $_SESSION['segment_next_date'] = get_input('segment_date');
            $_SESSION['segment_next_channel'] = get_input('channel');
            $_SESSION['segment_next_start_hour'] = $_SESSION['segment_next_end_hour'] = get_input('segment_end_hour');
            $_SESSION['segment_next_start_minute'] = $_SESSION['segment_next_end_minute'] = get_input('segment_end_minute');
            $_SESSION['segment_next_start_second'] = $_SESSION['segment_next_end_second'] = get_input('segment_end_second');
			forward("segment/add");
		}
	} else {
		register_error(elgg_echo('segment:error:cannot_save'));
		forward($error_forward_url);
	}
} else {
	register_error($error);
	forward($error_forward_url);
}